var O = { ok: "✓", err: "✖", dot: ".", comma: ",", bang: "!" }; if (process.platform === "win32") O.ok = "√", O.err = "×"; function E(G, D) { return D.concat([G]); } import X from "node:fs"; import V from "node:path"; import { err as A, ok as R } from "@serkonda7/ts-result"; import { globSync as U } from "glob"; import W from "vscode-textmate"; import $ from "node:fs"; import Q from "node:path"; import q from "node:url"; import J from "vscode-oniguruma"; async function S() { let G = new URL(import.meta.resolve("vscode-oniguruma")), D = Q.dirname(q.fileURLToPath(G)), H = Q.join(D, "onig.wasm"), M = $.readFileSync(H).buffer; return await J.loadWASM(M), { createOnigScanner(P) { return new J.OnigScanner(P); }, createOnigString(P) { return new J.OnigString(P); } }; } var K = new Map; function t(G, D, H) { let M = [], P = JSON.parse(X.readFileSync(G, "utf-8")), F = P.contributes?.grammars, z = P.contributes?.languages; if (Array.isArray(F)) { let T = V.dirname(G); for (let L of F) { if (typeof L.path === "string") L.path = V.join(T, L.path); else L.path = ""; if (typeof L.scopeName !== "string") L.scopeName = ""; if (typeof L.language !== "string") L.language = ""; M.push(L); } } if (M.push(...k(D)), M.length === 0) return A(Error("no grammars found in package.json")); let Y = new Map; for (let T of M) Y.set(T.language, T.scopeName); let B = new Map; if (Array.isArray(z)) for (let T of z) { if (typeof T.id !== "string") continue; let L = Y.get(T.id); if (!L) continue; if (Array.isArray(T.extensions)) for (let I of T.extensions) K.set(I.toLowerCase(), L); if (Array.isArray(T.filenames)) for (let I of T.filenames) B.set(I.toLowerCase(), L); } let Z = v(M); return R({ registry: Z, filenameToScope: (T) => H || B.get(T.toLowerCase()) || [...K].find((L) => T.toLowerCase().endsWith(L[0]))?.[1] || "" }); } function k(G) { const aaa = G.flatMap((D) => U(D)).map((D) => ({ path: D, scopeName: "", language: "" })); console.log(aaa); return aaa; } function v(G) { let D = S(), H = G.map((M) => ({ grammar: M, content: X.readFileSync(M.path, "utf-8") })); return y(H, D); } function y(G, D) { let H = new Map, M = new Map; for (let { grammar: P, content: F } of G) { let z = W.parseRawGrammar(F, P.path); if (P.scopeName.length === 0) P.scopeName = z.scopeName; if (z.fileTypes) for (let Y of z.fileTypes) K.set(Y.toLowerCase(), P.scopeName); if (H.set(P.scopeName, z), !P.injectTo) continue; for (let Y of P.injectTo) { let B = M.get(Y); if (!B) B = [], M.set(Y, B); B.push(P.scopeName); } } return new W.Registry({ onigLib: D, async loadGrammar(P) { let F = H.get(P); if (!F) return console.warn(`grammar not found for "${P}"`), null; return F; }, getInjections: (P) => { let F = P.split("."), z = [], Y = ""; for (let B of F) Y = Y ? `${Y}.${B}` : B, z.push(...M.get(Y) ?? []); return z; } }); } export { O as a, E as b, t as c };
