#!/usr/bin/env node
import{a as w,b as jj,c as Jj}from"./chunk-8c85n9w5.js";import*as Kj from"node:fs";import{unwrap as Xj}from"@serkonda7/ts-result";import Gj from"chalk";import{program as x}from"commander";import{globSync as Tj}from"glob";import*as O from"node:fs";import{EOL as Zj}from"node:os";import*as m from"node:path";import{sep as $j}from"node:path";import*as z from"node:tty";import v from"chalk";class p{reporters;constructor(...j){this.reporters=j}reportTestResult(j,J,K){this.reporters.forEach((Q)=>Q.reportTestResult(j,J,K))}reportGrammarTestError(j,J,K){this.reporters.forEach((Q)=>Q.reportGrammarTestError(j,J,K))}reportParseError(j,J){this.reporters.forEach((K)=>K.reportParseError(j,J))}reportSuiteResult(){this.reporters.forEach((j)=>j.reportSuiteResult())}}class P{suites=[];reportPath;constructor(j){this.reportPath=j}reportParseError(j,J){this.getSuite(j).cases.push({name:"Parse test file",classname:this.caseClassname(j),failures:[{type:"error",message:"Failed to parse test file",body:`${J}`}]})}reportGrammarTestError(j,J,K){this.getSuite(j,J).cases.push({name:"Run grammar tests",classname:this.caseClassname(j),failures:[{type:"error",message:"Error when running grammar tests",body:`${K}`}]})}red(j){return j}gray(j){return j}whiteBright(j){return j}getSuite(j,J){let K={file:`TEST-${j.replaceAll($j,".")}.xml`,name:J?.metadata.description||j,cases:[]};return this.suites.push(K),K}getCase(j,J,K){let Q=`${J}:${K}`;for(let U of j.cases)if(U.name===Q)return U;let Z={name:Q,classname:this.caseClassname(J),failures:[]};return j.cases.push(Z),Z}reportSuiteResult(){O.mkdirSync(this.reportPath,{recursive:!0});for(let j of this.suites.values())O.writeFileSync(m.resolve(this.reportPath,j.file),this.renderSuite(j))}renderSuite(j){return`
<testsuite
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="https://maven.apache.org/surefire/maven-surefire-plugin/xsd/surefire-test-report.xsd"
    name="${j.name}"
    tests="${j.cases.length}"
    failures="${this.suiteFailuresCount(j)}"
    errors="${this.suiteErrorsCount(j)}"
    skipped="0"
>${j.cases.reduce((J,K)=>J+`
`+this.renderCase(K),"")}
</testsuite>
`}renderCase(j){return`  <testcase name="${j.name}" ${this.classnameAttr(j)}time="0">${j.failures.reduce((J,K)=>J+`
`+this.renderFailure(K),"")}${this.newlineIfHasItems(j.failures)}</testcase>`}classnameAttr(j){return j.classname?`classname="${j.classname}" `:""}renderFailure(j){return`    <${j.type} message="${j.message}" type="${j.type==="failure"?"TestFailure":"GrammarTestError"}">${this.escapedXml(j.body)}</${j.type}>`}newlineIfHasItems(j){return j.length===0?"":`
`}escapedXml(j){return j.replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/'/g,"&apos;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}}class d extends P{reportTestResult(j,J,K){let Q=this.getSuite(j,J);for(let Z of J.test_lines){let U=this.getCase(Q,j,Z.line_nr);for(let H of K){if(H.line!==Z.line_nr-1)continue;let{l:$,s:V,e:N}=a(H),B=[];F(H,"",200,(Y)=>B.push(Y),this),y(J,H,"",(Y)=>B.push(Y),this),U.failures.push({type:"failure",message:`Assertion failed at ${$}:${V}:${N}`,body:B.join(`
`)})}}}caseClassname(){return}suiteFailuresCount(j){return j.cases.reduce((J,K)=>J+K.failures.reduce((Q,Z)=>Q+(Z.type==="failure"?1:0),0),0)}suiteErrorsCount(j){return j.cases.reduce((J,K)=>J+K.failures.reduce((Q,Z)=>Q+(Z.type==="error"?1:0),0),0)}}class u extends P{reportTestResult(j,J,K){let Q=this.getSuite(j,J);for(let Z of J.test_lines){let U=this.getCase(Q,j,Z.line_nr),H=[];for(let $ of K){if($.line!==Z.line_nr-1)continue;t(j,$,"",(V)=>H.push(V),this),F($,"",200,(V)=>H.push(V),this),y(J,$,"",(V)=>H.push(V),this),H.push("")}if(H.length>0)U.failures.push({type:"failure",message:`Failed at soure line ${Z.line_nr}`,body:H.join(`
`)})}}caseClassname(j){return j}suiteFailuresCount(j){return j.cases.reduce((J,K)=>J+(K.failures.some((Q)=>Q.type==="failure")?1:0),0)}suiteErrorsCount(j){return j.cases.reduce((J,K)=>J+(K.failures.some((Q)=>Q.type==="error")?1:0),0)}}var T="  ",Uj=z.isatty(1)&&z.isatty(2),f=75;if(Uj)f=process.stdout.getWindowSize()[0];function c(j,J,K){console.log(v.red(w.err)+" testcase "+v.gray(j)+" aborted due to an error"),console.log(K)}function l(j,J){console.log(v.red("ERROR")+" can't parse testcase: "+v.whiteBright(j)),console.log(J)}class o{reportTestResult(j,J,K){if(K.length===0)console.log(v.green(w.ok)+" "+v.whiteBright(j)+" run successfuly.");else K.forEach((Q)=>{console.log(`ERROR ${j}:${Q.line+1}:${Q.start+1}:${Q.end+1} ${this.renderCompactErrorMsg(J,Q)}`)})}renderCompactErrorMsg(j,J){let K="";if(J.missing&&J.missing.length>0)K+=`Missing required scopes: [ ${J.missing.join(" ")} ] `;if(J.unexpected&&J.unexpected.length>0)K+=`Prohibited scopes: [ ${J.unexpected.join(" ")} ] `;if(J.actual!==void 0)K+=`actual scopes: [${J.actual.join(" ")}]`;return K}reportParseError=l;reportGrammarTestError=c;reportSuiteResult(){}}class n{reportTestResult(j,J,K){if(K.length===0)console.log(v.green(w.ok)+" "+v.whiteBright(j)+" run successfuly.");else console.log(v.red(w.err+" "+j+" failed")),K.forEach((Q)=>{t(j,Q,T,console.log,v),F(Q,T,f,console.log,v),y(J,Q,T,console.log,v),console.log(Zj)}),console.log("")}reportParseError=l;reportGrammarTestError=c;reportSuiteResult(){}}function t(j,J,K,Q,Z){let{l:U,s:H,e:$}=a(J);Q(K+"at ["+Z.whiteBright(`${j}:${U}:${H}:${$}`)+"]:")}function a(j){return{l:j.line+1,s:j.start+1,e:j.end+1}}function F(j,J,K,Q,Z){let U=j.line+1+": ",H=" ".repeat(j.start)+"^".repeat(j.end-j.start),$=K-U.length-T.length-5,V=j.end>$?Math.max(0,j.start-8):0,N=j.srcLineText.substr(V),B=H.substr(V);Q(J+Z.gray(U)+N.substr(0,$)),Q(J+" ".repeat(U.length)+B.substr(0,$))}function y(j,J,K,Q,Z){if(J.missing&&J.missing.length>0)Q(Z.red(K+"missing required scopes: ")+Z.gray(J.missing.join(" ")));if(J.unexpected&&J.unexpected.length>0)Q(Z.red(K+"prohibited scopes: ")+Z.gray(J.unexpected.join(" ")));if(J.actual!==void 0)Q(Z.red(K+"actual: ")+Z.gray(J.actual.join(" ")))}function _(j){return j?new o:new n}function s(j,J,K){if(K){let Q=J==="gitlab"?new u(K):new d(K);return new p(_(j),Q)}return _(j)}import{err as W,ok as X}from"@serkonda7/ts-result";function L(j,J,K){return{src:j,line_nr:J,scope_asserts:K}}var Vj="Invalid header",Hj='Expected format: <comment token> SYNTAX TEST "<scopeName>" "description"',Bj="Expected non-empty test",Nj="Assertion requires a scope",vj="Cannot parse assertion",Yj="(?<comment>\\S+)",Ij='"(?<scope>[^"]+)"',Dj='(?:\\s+"(?<desc>[^"]+)")?',Wj=new RegExp(`^${Yj}\\s+SYNTAX\\s+TEST\\s+${Ij}${Dj}\\s*$`),i=/[^.\s]+(?:\.[^.\s]+)*/g;if(!RegExp.escape)RegExp.escape=(j)=>String(j).replace(/[.*+?^${}()|[\]\\]/g,"\\$&");function r(j){let J=Wj.exec(j);if(!J?.groups)return W(SyntaxError(Vj,{cause:Hj}));return X({comment_token:J.groups.comment,scope:J.groups.scope,description:J.groups.desc??""})}function S(j){let J=j.split(/\r\n|\n/);if(J.length<=1)return W(Error(Bj));let K=r(J[0]);if(K.error)return W(K.error);let{comment_token:Q}=K.value,Z=new RegExp(`\\s*${RegExp.escape(Q)}\\s*(\\^|<[~]*[-]+)`);function U(B){return Z.test(B)}let H=new C(Q.length),$=[],V=[],N=0;for(let B=1;B<J.length;B++){let Y=J[B];if(U(Y)){let M=H.parse_line(Y);if(M.error)return W(M.error);V.push(M.value);continue}if(V.length>0)$.push(L(J[N],N+1,V.slice()));N=B,V=[]}if(V.length>0)$.push(L(J[N],N+1,V.slice()));return X({metadata:K.value,test_lines:$})}class C{comment_offset;line="";pos=0;constructor(j){this.comment_offset=j}parse_line(j){this.line=j,this.pos=0,this.skip_whitespace(),this.pos+=this.comment_offset,this.skip_whitespace();let J=this.parse_assertion_range();if(J.error)return W(J.error);let{from:K,to:Q}=J.value,{scopes:Z,excludes:U}=this.parse_scopes_and_exclusions();if(Z.length===0&&U.length===0)return W(SyntaxError(Nj));return X({from:K,to:Q,scopes:Z,excludes:U})}skip_whitespace(){while(this.line[this.pos].match(/^\s$/))this.pos++}parse_assertion_range(){let j=this.pos,J=this.line[this.pos];if(this.pos++,J==="^"){while(this.line[this.pos]==="^")this.pos++;return X({from:j,to:this.pos})}if(J==="<"){let K=0;while(this.line[this.pos]==="~")this.pos++,K++;let Q=0;while(this.line[this.pos]==="-")this.pos++,Q++;return X({from:K,to:K+Q})}return W(SyntaxError(vj))}parse_scopes_and_exclusions(){let j=this.line.slice(this.pos),[J,K]=j.split(/\s+!\s+/,2),Q=[],Z=[];if(J)Q=[...J.matchAll(i)].map((U)=>U[0]);if(K)Z=[...K.matchAll(i)].map((U)=>U[0]);return{scopes:Q,excludes:Z}}}function E(j,J,K){return j.filter((Q)=>{return J<Q.endIndex&&K>Q.startIndex})}function h(j,J){return j.filter((K)=>J.includes(K))}function g(j,J){if(j.length===0)return[];let K=0;for(let Q of J)if(Q===j[K]){if(K++,K===j.length)return[]}return j.slice(K)}import{err as e,ok as Mj}from"@serkonda7/ts-result";import qj from"vscode-textmate";class A{registry;constructor(j){this.registry=j}async test_file(j){let J=S(j);if(J.error)return e(J.error);let K=J.value,Q=await this.registry.loadGrammar(K.metadata.scope);if(!Q)return e(Error(`Could not load scope ${K.metadata.scope}`));let Z=qj.INITIAL,U=[];for(let H of K.test_lines){let{line_nr:$,src:V,scope_asserts:N}=H,B=V.length,{tokens:Y,ruleStack:M}=Q.tokenizeLine(V,Z);Z=M;for(let b of Y){let I=b.scopes;for(let D=I.length-1;D>=0;D--){let G=I[D].replaceAll(/\s+/g,"");if(G)I[D]=G;else I.splice(D,1)}}N.forEach(({from:b,to:I,scopes:D,excludes:G})=>{let Qj=E(Y,b,I);if(I>B&&!wj(Y,V.length)){U.push(this.eol_failure($,V,B,I));return}Qj.forEach((q)=>{let R=h(G,q.scopes),k=g(D,q.scopes);if(k.length||R.length)U.push({missing:k,actual:q.scopes,unexpected:R,line:$-1,srcLineText:V,start:q.startIndex,end:q.endIndex})})})}return Mj({test_case:K,failures:U})}eol_failure(j,J,K,Q){return{missing:[],unexpected:[],actual:["EOL"],line:j-1,srcLineText:J,start:K,end:Q}}}function wj(j,J){if(j.length!==1)return!1;let K=j[0];if(K.startIndex>0||K.endIndex<J)return!1;return K.scopes.length===1}x.description("Run Textmate grammar test cases using vscode-textmate").option("-g, --grammar <grammar>","Path to a grammar file. Multiple options supported. 'scopeName' is taken from the grammar",jj,[]).option("--config <configuration.json>","Path to language configuration. Default: `package.json`","package.json").option("-c, --compact","Display output in the compact format, which is easier to use with VSCode problem matchers").option("--xunit-report <report.xml>","Path to directory where test reports in the XUnit format will be emitted in addition to console output").option("--xunit-format <generic|gitlab>","Format of XML reports generated when --xunit-report is used. `gitlab` format is suitable for viewing the results in GitLab CI/CD web GUI").argument("<testcases...>",'A glob pattern(s) which specifies testcases to run, e.g. "./tests/**/test*.dhall". Quotes are important!').parse(process.argv);async function Oj(){let j=x.opts(),J=x.args.flatMap(($)=>Tj($));if(J.length===0)return console.error(Gj.red("ERROR")+" no test cases found"),1;let{registry:K}=Xj(Jj(j.config,j.grammar)),Q=new A(K),Z=s(j.compact,j.xunitFormat,j.xunitReport);async function U($){let V=Kj.readFileSync($,"utf8"),N=await Q.test_file(V);if(N.error)return Z.reportParseError($,N.error),1;let B=N.value;return Z.reportTestResult($,B.test_case,B.failures),B.failures.length===0?0:1}let H=[];for(let $ of J){let V=await U($);H.push(V)}return Z.reportSuiteResult(),H.every(($)=>$===0)?0:1}Oj().then((j)=>{process.exitCode=j});
