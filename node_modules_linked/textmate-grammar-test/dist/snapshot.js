#!/usr/bin/env node
import { a as k, b as f, c as g } from "./chunk-8c85n9w5.js";
import N from "node:fs";
import { EOL as v } from "node:os";
import R from "node:path";
import { unwrap as _ } from "@serkonda7/ts-result";
import Q from "chalk";
import { program as L } from "commander";
import *as h from "diff";
import { globSync as a } from "glob";
import d from "vscode-textmate";
async function C(q, J, j) {
	let K = await q.loadGrammar(J);
	if (!K) throw Error(`Could not load scope ${J}`);
	let B = d.INITIAL;
	return j.split(/\n|\r\n/).map((G) => {
		let { tokens: H, ruleStack: Z } = K.tokenizeLine(G, B);
		B = Z;
		for (let $ of H) {
			let U = $.scopes;
			for (let V = U.length - 1;
				V >= 0;
				V--) {
					let Y = U[V].replaceAll(/\s+/g, "");
				if (Y) U[V] = Y;
				else U.splice(V, 1);
			}
		} return { line: G, tokens: H };
	});
} import { err as l, ok as i } from "@serkonda7/ts-result";
var b = ">", A = "#", T = 1;
function E(q) {
	let J = [], j = q.split(/\n|\r\n/), K = 0;
	if (j[0].startsWith("#")) K++;
	while (K < j.length) {
		let B = j[K];
		if (K++, !B.startsWith(b)) return l(Error(`Expected source line starting with '${b}'`));
		let G = [];
		while (K < j.length) {
			let H = j[K];
			if (!H.startsWith(A)) break;
			let Z = H.indexOf("^"), $ = H.indexOf(" ", Z), U = c(H, $ + 1);
			G.push({ startIndex: Z - T, endIndex: $ - T, scopes: U }), K++;
		} J.push({ line: B.slice(1), tokens: G });
	} return i(J);
} function c(q, J) {
	return q.slice(J).split(" ").filter((j) => j.length > 0);
} function y(q, J) {
	let j = [`# SYNTAX TEST "${J}" "autogenerated snapshot test"`];
	for (let { line: K, tokens: B } of q) j.push(b + K), j.push(...o(B));
	return j.join(`
`);
} function o(q) {
	let J = [];
	for (let j of q) {
		let K = A;
		K += " ".repeat(j.startIndex), K += "^".repeat(j.endIndex - j.startIndex), K += ` ${j.scopes.join(" ")}`, J.push(K);
	} return J;
} L.description("Run VSCode textmate grammar snapshot tests").option("-u, --updateSnapshot", "overwrite all snap files with new changes").option("--config <configuration.json>", "Path to language configuration. Default: `package.json`", "package.json").option("--printNotModified", "include not modified scopes in the output", !1).option("--expandDiff", 'produce each diff on two lines prefixed with "++" and "--"', !1).option("-g, --grammar <grammar>", "A glob pattern to grammar file(s). Multiple options supported.", f, []).option("-o, --outdir <outdir>", "Specify output directory of testcases", "").option("-s, --scope <scope>", "Explicitly specify scope of testcases, e.g. source.xy").argument("<testcases...>", 'A glob pattern(s) which specifies testcases to run, e.g. "./tests/**/test*.dhall". Quotes are important!').parse(process.argv);
async function s() {
	console.log(L);
	console.log(L.opts());
	let q = L.opts(), j = L.args.flatMap((H) => a(H)).filter((H) => !H.endsWith(".snap"));
	if (j.length === 0) return console.error(Q.red("ERROR") + " no test cases found"), 1;
	console.log(q.grammar);
	let { registry: K, filenameToScope: B } = _(g(q.config, q.grammar, q.scope)), G = [];
	for (let H of j) {
		let Z = N.readFileSync(H, "utf-8"), $ = B(R.basename(H));
		if ($.length === 0) {
			console.log(Q.red("ERROR") + " can't run testcase: " + H), console.log("No scope is associated with the file."), G.push(1);
			continue;
		} let U = await C(K, $, Z), V = q.outdir.length > 0 ? R.join(q.outdir, R.basename(H)) : H, Y = V + ".snap";
		if (N.existsSync(Y)) if (q.updateSnapshot) {
			console.log(Q.yellowBright("Updating snapshot for ") + Q.whiteBright(Y));
			let z = y(U, $);
			N.writeFileSync(Y, z, "utf-8"), G.push(0);
		} else {
			let z = N.readFileSync(Y, "utf-8"), O = _(E(z));
			G.push(n(V, O, U, q));
		} else {
			console.log(Q.yellowBright("Generating snapshot ") + Q.whiteBright(Y));
			let z = y(U, $);
			N.writeFileSync(Y, z, "utf-8"), G.push(0);
		}
	} return G.every((H) => H === 0) ? 0 : 1;
} s().then((q) => {
	process.exitCode = q;
});
var I = "  ";
function n(q, J, j, K) {
	if (J.length !== j.length) return console.log(Q.red("ERROR running testcase ") + Q.whiteBright(q) + Q.red(" snapshot and actual file contain different number of lines.")), 1;
	for (let Z = 0;
		Z < J.length;
		Z++) {
			let $ = J[Z], U = j[Z];
		if ($.line !== U.line) return console.log(Q.red("ERROR running testcase ") + Q.whiteBright(q) + Q.red(` source different snapshot at line ${Z + 1}.${v} expected: ${$.line}${v} actual: ${U.line}${v}`)), 1;
	} let B = j.filter((Z) => Z.line.trim().length > 0), G = J.filter((Z) => Z.line.trim().length > 0), H = m(G.map((Z, $) => {
		let U = B[$], V = u((W) => `${W.startIndex}:${W.startIndex}`, Z.tokens), Y = u((W) => `${W.startIndex}:${W.startIndex}`, U.tokens), z = Z.tokens.filter((W) => Y[`${W.startIndex}:${W.startIndex}`] === void 0).map((W) => {
			return { changes: [{ text: W.scopes.join(" "), changeType: D }], from: W.startIndex, to: W.endIndex };
		}), O = U.tokens.filter((W) => V[`${W.startIndex}:${W.startIndex}`] === void 0).map((W) => {
			return { changes: [{ text: W.scopes.join(" "), changeType: F }], from: W.startIndex, to: W.endIndex };
		}), S = m(U.tokens.map((W) => {
			let X = V[`${W.startIndex}:${W.startIndex}`];
			if (X !== void 0) {
				let w = h.diffArrays(X.scopes, W.scopes);
				if (w.length === 1 && !w[0].added && !w[0].removed) return [];
				return [{
					changes: w.map((P) => {
						let r = P.added ? F : P.removed ? D : M;
						return { text: P.value.join(" "), changeType: r };
					}), from: W.startIndex, to: W.endIndex
				}];
			} else return [];
		})).concat(O).concat(z).sort((W, X) => (W.from - X.from) * 1e4 + (W.to - X.to));
		if (S.length > 0) return [[S, Z.line, $]];
		else return [];
	}));
	if (H.length > 0) {
		if (console.log(Q.red("ERROR in test case ") + Q.whiteBright(q)), console.log(I + I + Q.red("-- existing snapshot")), console.log(I + I + Q.green("++ new changes")), console.log(), K.expandDiff) e(H, K);
		else t(H, K);
		return console.log(), 1;
	} else return console.log(Q.green(k.ok) + " " + Q.whiteBright(q) + " run successfully."), 0;
} function t(q, J) {
	q.forEach(([j, K, B]) => {
		let G = p(K, B);
		j.forEach((H) => {
			let Z = H.changes.filter(($) => J.printNotModified || $.changeType !== M).map(($) => {
				return ($.changeType === F ? Q.green : $.changeType === D ? Q.red : Q.gray)($.text);
			}).join(" ");
			jj(G, H.from, H.to, Z);
		}), console.log();
	});
} function e(q, J) {
	q.forEach(([j, K, B]) => {
		let G = p(K, B);
		j.forEach((H) => {
			let Z = H.changes.filter((U) => U.changeType === D || U.changeType === M && J.printNotModified).map((U) => {
				return Q.red(U.text);
			}).join(" "), $ = H.changes.filter((U) => U.changeType === F || U.changeType === M && J.printNotModified).map((U) => {
				return Q.green(U.text);
			}).join(" ");
			x(G, H.from, H.to, Q.red("-- ") + Z, D), x(G, H.from, H.to, Q.green("++ ") + $, F);
		}), console.log();
	});
} function u(q, J) {
	return J.reduce((j, K) => {
		return j[q(K)] = K, j;
	}, {});
} function m(q) {
	return q.reduce((J, j) => J.concat(j), []);
} var M = 0, D = 1, F = 2;
function p(q, J) {
	let j = J + 1 + ": ";
	return console.log(I + Q.gray(j) + q), j.length;
} function jj(q, J, j, K) {
	let B = " ".repeat(J) + "^".repeat(j - J);
	console.log(I + " ".repeat(q) + B + " " + K);
} function x(q, J, j, K, B) {
	let G = B === F ? Q.green : B === D ? Q.red : Q.gray, H = B === F ? "++" : B === D ? "--" : "  ", Z = G(" ".repeat(J) + "^".repeat(j - J));
	console.log(G(H) + " ".repeat(q) + Z + " " + K);
}
